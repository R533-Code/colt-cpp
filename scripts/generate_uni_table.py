import os

PROJECT_PATH = os.path.abspath(os.path.dirname(os.path.abspath(__file__)) + "/..")
HEADER_START = (
"// GENERATED BY 'scripts/generate_uni_table'\n"
"#ifndef __COLT_GEN_XID_TABLE\n"
"#define __COLT_GEN_XID_TABLE\n\n"
"namespace clt::uni\n"
"{\n  // clang-format off\n")

HEADER_END =(
"  // clang-format on\n"
"} // namespace clt::uni\n\n"
"#endif //!__COLT_GEN_XID_TABLE")

os.chdir(PROJECT_PATH)

file = open("resources/DerivedCoreProperties.txt")
def filter_lines(line: str)->bool:
  line = line.strip()
  if line.startswith('#'):
    return False
  return "XID_Start" in line or "XID_Continue" in line

XID_Start_Table = []
XID_Continue_Table = []
def add_to_table(value, is_start):
  table = XID_Start_Table if is_start else XID_Continue_Table
  table.append(value)

for line in filter(filter_lines, file):
  is_start = "XID_Start" in line
  if ".." in line:
    dotdot = line.find("..")
    start = line[0:dotdot]
    end = line[dotdot+2:line.find(";")]
    for i in range(int(start, 16), int(end, 16)):
      add_to_table(i, is_start)
  else:
    add_to_table(int(line[0:line.find(";")], 16), is_start)

XID_Start_Table.sort()
XID_Continue_Table.sort()

def ranges(nums):
  nums = sorted(set(nums))
  gaps = [[s, e] for s, e in zip(nums, nums[1:]) if s+1 < e]
  edges = iter(nums[:1] + sum(gaps, []) + nums[-1:])
  return list(zip(edges, edges))

write = open("include/colt/uni/gen/xid_table.h", "w")
write.write(HEADER_START)

RANGE_START = ranges(XID_Start_Table)
write.write("  constexpr bool is_xid_start(char32_t chr) noexcept\n  {\n")
for start, end in ranges(XID_Start_Table):
  if start == end:
    write.write(f"    if (chr == {start}) return true;\n")
  else:
    write.write(f"    if ({start} <= chr && chr <= {end}) return true;\n")
write.write("    return false;\n  }\n\n")

write.flush()

write.write("  constexpr bool is_xid_continue(char32_t chr) noexcept\n  {\n")

RANGE_CONTINUE = list(set(ranges(XID_Continue_Table)) - set(RANGE_START))
RANGE_CONTINUE.sort()
write.write(f"    if (is_xid_start(chr)) return true;\n")  
for start, end in RANGE_CONTINUE:
  if start == end:
    write.write(f"    if (chr == {start}) return true;\n")
  else:
    write.write(f"    if ({start} <= chr && chr <= {end}) return true;\n")
write.write("    return false;\n  }\n")

write.flush()
write.write(HEADER_END)
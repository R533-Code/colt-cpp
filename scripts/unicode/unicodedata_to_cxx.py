import parseunicode
import colt
from colt import frac
from colt import CodePoint
from colt import CodePointRange
import time

def time_fn(fn, *args, **kwargs):
  start = time.time()
  ret = fn(*args, **kwargs)
  end = time.time()
  print(f"{fn.__name__: <24}: {end - start:.2f}s")
  return ret

def round_to_nearest_bits(num):
  if num <= 0:
    raise ValueError("Number must be positive.")  
  bit = 8
  while 2**bit < num:
    bit *= 2
  return bit

def canonicalize_identifier(identifier: str):
  identifier = identifier.split()[0]
  if identifier[0].isdigit():
    identifier = "_" + identifier
  return identifier.replace('.', '_').replace('-', '_').strip()

def write_properties_as_cxx(PROPERTIES: dict[str, parseunicode.Property], ALLALIASES: dict[str, str]):
  with open("../../include/colt/unicode/properties.h", "w") as file:
    print("// !! Generated by unicodedata_to_cxx.py !!", file=file)
    print(f"#ifndef __COLT_UNICODE_PROPERTIES__\n#define __COLT_UNICODE_PROPERTIES__\n\n#include <cstdint>\n", file=file)
    print("namespace clt::uni {", file=file)
    for key, value in PROPERTIES.items():
      if len(value.KEYS) == 0:
        continue
      print(f"enum class {value.FULLNAME}", file=file, end='')
      str = ""
      i = 0
      used_key = set()
      for k, v in value.KEYS.items():
        k, v = canonicalize_identifier(k), canonicalize_identifier(v)
        if k in used_key:
          continue
        if k == v:
          str += f"  {k} = {i},\n"
          i += 1
        else:
          str += f"  {k} = {v},\n"
        used_key.add(k)
      print(f" : uint{round_to_nearest_bits(i)}_t {{", file=file)
      print(str, file=file, end='')
      print("};",file=file)
      if key != value.FULLNAME:
        print(f"using {key} = {value.FULLNAME};\n", file=file)
      else:
        print(file=file)
      if value.GROUP_FN is not None:
        for k, v in value.GROUP_FN.items():
          print(f"constexpr bool is_{value.FULLNAME.strip()}_{k}({value.FULLNAME.strip()} c) noexcept {{", file=file)
          print(f"  using enum {value.FULLNAME};\n  return clt::is_one_of(c, {', '.join(v)});\n}}\n", file=file)
    print("} // namespace clt::uni\n\n#endif // !__COLT_UNICODE_PROPERTIES__", file=file)

def write_propvalues_as_cxx(CODEPOINTS: list[parseunicode.CodePointInfo], PROPERTIES: dict[str, parseunicode.Property]):
  def desc(kind: parseunicode.PropertyKind, keys):
    value_desc = ""
    if kind == parseunicode.PropertyKind.ENM:
      if "N" in keys and "Y" in keys:
        value_desc = "(binary property)"
      else:
        value_desc = "(enumerated property)"
    elif kind == parseunicode.PropertyKind.NUM:
      value_desc = "(numeric property)"
    elif kind == parseunicode.PropertyKind.STR:
      value_desc = "(string property)"
    elif kind == parseunicode.PropertyKind.PTR:
      value_desc = "(char32_t* property)"
    return value_desc
  def type(kind: parseunicode.PropertyKind, name: str):
    if kind == parseunicode.PropertyKind.ENM:
      return name
    elif kind == parseunicode.PropertyKind.NUM:
      return "double"
    elif kind == parseunicode.PropertyKind.STR:
      return "const char*"
    elif kind == parseunicode.PropertyKind.PTR:
      return "char32_t*"    
    
  # Break down the data as planes
  PLANES = colt.chunk(CODEPOINTS, parseunicode.MAX_PLANE)
  with open("../../include/colt/unicode/propvalues.h", "w") as file:
    print("// !! Generated by unicodedata_to_cxx.py !!", file=file)
    print(f"#ifndef __COLT_UNICODE_PROPVALUES__\n#define __COLT_UNICODE_PROPVALUES__\n\n#include <limits>\n#include \"colt/unicode/properties.h\"\n#include \"colt/typedefs.h\"\n", file=file)
    print("namespace clt::uni {", file=file)
    print("  struct CodePointProperties {", file=file)
    for k, v in PROPERTIES.items():
      if v.DEFAULT_VALUE is not None:
        print(f"\n    static consteval auto default_value_{v.FULLNAME}(uint32_t cp) noexcept {{", file=file)
        if v.DEFAULT_VALUE[0].begin.value != 0:
          print(f"      if (0x{v.DEFAULT_VALUE[0].begin} <= cp && cp <= 0x{v.DEFAULT_VALUE[0].end})", file=file)
        else:
          print(f"      if (cp <= 0x{v.DEFAULT_VALUE[0].end})", file=file)
        
        if (v.DEFAULT_VALUE[1] == "<code point>"):
          print(f"        return cp;", file=file)
        elif (v.DEFAULT_VALUE[1].lower() == "nan"):
          print(f"        return std::numeric_limits<double>::quiet_NaN();", file=file)
        elif (v.DEFAULT_VALUE[1].lower() == "<none>"):
          print(f"        return nullptr;", file=file)
        elif (v.KIND == parseunicode.PropertyKind.ENM):
          print(f"        return {v.FULLNAME}::{v.DEFAULT_VALUE[1]};", file=file)
        print(f"      clt::unreachable(\"Invalid code point!\");\n    }}", file=file)
      print(f"    // {v.FULLNAME} <=> {k} {desc(v.KIND, v.KEYS)}\n    {type(v.KIND, v.FULLNAME)} _{v.FULLNAME};", file=file)
    print(f"  }}; // struct CodePointProperties", file=file)
    print("} // namespace clt::uni\n\n#endif // !__COLT_UNICODE_PROPVALUES__", file=file)

try:
  # dict of name str to abrv.
  ALLALIASES = time_fn(parseunicode.parse_propertyaliases)
  # dict of abrv. str to Property
  PROPERTIES = time_fn(parseunicode.parse_propertyvalue)  
  # Convert to C++
  time_fn(write_properties_as_cxx, PROPERTIES, ALLALIASES)
  print("Finished writing 'colt/unicode/properties.h'!\n")
  
  # list of all properties
  PROPVALUES = time_fn(parseunicode.parse_properties)
  # dict of all
  CODEPOINTS = time_fn(parseunicode.parse_unicodedata)
  time_fn(write_propvalues_as_cxx, CODEPOINTS, PROPERTIES)
  print("Finished writing 'colt/unicode/propvalues.h'!\n")  
except Exception as E:
  print(f"Error: Exception \"{str(E)}\"")

input("Press Enter to close...")
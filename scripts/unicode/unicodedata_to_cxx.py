import parseunicode
import colt
from colt import frac
from colt import CodePoint
from colt import CodePointRange
import time

def time_fn(fn, *args, **kwargs):
  start = time.time()
  ret = fn(*args, **kwargs)
  end = time.time()
  print(f"{fn.__name__: <24}: {end - start:.2f}s")
  return ret

def round_to_nearest_bits(num):
  if num <= 0:
    raise ValueError("Number must be positive.")  
  bit = 8
  while 2**bit < num:
    bit *= 2
  return bit

def canonicalize_identifier(identifier: str):
  identifier = identifier.split()[0]
  if identifier[0].isdigit():
    identifier = "_" + identifier
  return identifier.replace('.', '_').replace('-', '_').strip()

def write_properties_as_cxx(PROPERTIES: dict[str, parseunicode.Property], ALLALIASES: dict[str, str]):
  with open("../../include/colt/unicode/properties.h", "w") as file:
    print("// !! Generated by unicodedata_to_cxx.py !!", file=file)
    print(f"#ifndef __COLT_UNICODE_PROPERTIES__\n#define __COLT_UNICODE_PROPERTIES__\n\n#include <cstdint>\n", file=file)
    print("namespace clt::uni {", file=file)
    for key, value in PROPERTIES.items():
      if len(value.KEYS) == 0:
        continue
      print(f"enum class {value.FULLNAME}", file=file, end='')
      str = ""
      i = 0
      used_key = set()
      for k, v in value.KEYS.items():
        k, v = canonicalize_identifier(k), canonicalize_identifier(v)
        if k in used_key:# or '#' in k:
          continue
        if k == v:
          str += f"  {k} = {i},\n"
          i += 1
        else:
          str += f"  {k} = {v},\n"
        used_key.add(k)
      print(f" : uint{round_to_nearest_bits(i)}_t {{", file=file)
      print(str, file=file, end='')
      print("};",file=file)
      if key != value.FULLNAME:
        print(f"using {key} = {value.FULLNAME};\n", file=file)
      else:
        print(file=file)
      if value.GROUP_FN is not None:
        for k, v in value.GROUP_FN.items():
          print(f"constexpr bool is_{value.FULLNAME.strip()}_{k}({value.FULLNAME.strip()} c) noexcept {{", file=file)
          print(f"  using enum {value.FULLNAME};\n  return clt::is_one_of(c, {', '.join(v)});\n}}\n", file=file)
    print("} // namespace clt::uni\n\n#endif // !__COLT_UNICODE_PROPERTIES__", file=file)
  

try:
  # dict of name str to abrv.
  ALLALIASES = time_fn(parseunicode.parse_propertyaliases)
  # dict of abrv. str to Property
  PROPERTIES = time_fn(parseunicode.parse_propertyvalue)  
  # Convert to C++
  time_fn(write_properties_as_cxx, PROPERTIES, ALLALIASES)
  print("Finished writing 'colt/unicode/properties.h'!\n")
  
  # list of all properties
  PROPVALUES = time_fn(parseunicode.parse_properties)
  ## dict of all
  #CODEPOINTS = time_fn(parseunicode.parse_unicodedata)
  #
  ## Break down the data as planes
  #PLANES = colt.chunk(CODEPOINTS, parseunicode.MAX_PLANE)
  #for i, plane in enumerate(PLANES):
  #  print(f"{i}: {len(plane)}, {len(list(filter(parseunicode.is_assigned_character, plane)))}")
except Exception as E:
  print(f"Error: Exception \"{str(E)}\"")

input("Press Enter to close...")